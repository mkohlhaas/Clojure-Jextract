// Generated by jextract

package org.unix;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class time_h {

    time_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _TIME_H 1
     * }
     */
    public static int _TIME_H() {
        return _TIME_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2Y = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2Y 0
     * }
     */
    public static int __GLIBC_USE_ISOC2Y() {
        return __GLIBC_USE_ISOC2Y;
    }
    private static final int __GLIBC_USE_ISOC23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC23 0
     * }
     */
    public static int __GLIBC_USE_ISOC23() {
        return __GLIBC_USE_ISOC23;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_TIME_BITS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_TIME_BITS64 1
     * }
     */
    public static int __USE_TIME_BITS64() {
        return __USE_TIME_BITS64;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C23_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C23_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C23_STRTOL() {
        return __GLIBC_USE_C23_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)42L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 42
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int _BITS_TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME_H 1
     * }
     */
    public static int _BITS_TIME_H() {
        return _BITS_TIME_H;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }
    private static final int CLOCK_MONOTONIC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 1
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }
    private static final int CLOCK_PROCESS_CPUTIME_ID = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 2
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int CLOCK_THREAD_CPUTIME_ID = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 3
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }
    private static final int CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }
    private static final int CLOCK_REALTIME_COARSE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_COARSE 5
     * }
     */
    public static int CLOCK_REALTIME_COARSE() {
        return CLOCK_REALTIME_COARSE;
    }
    private static final int CLOCK_MONOTONIC_COARSE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_COARSE 6
     * }
     */
    public static int CLOCK_MONOTONIC_COARSE() {
        return CLOCK_MONOTONIC_COARSE;
    }
    private static final int CLOCK_BOOTTIME = (int)7L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME 7
     * }
     */
    public static int CLOCK_BOOTTIME() {
        return CLOCK_BOOTTIME;
    }
    private static final int CLOCK_REALTIME_ALARM = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_ALARM 8
     * }
     */
    public static int CLOCK_REALTIME_ALARM() {
        return CLOCK_REALTIME_ALARM;
    }
    private static final int CLOCK_BOOTTIME_ALARM = (int)9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME_ALARM 9
     * }
     */
    public static int CLOCK_BOOTTIME_ALARM() {
        return CLOCK_BOOTTIME_ALARM;
    }
    private static final int CLOCK_TAI = (int)11L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_TAI 11
     * }
     */
    public static int CLOCK_TAI() {
        return CLOCK_TAI;
    }
    private static final int TIMER_ABSTIME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIMER_ABSTIME 1
     * }
     */
    public static int TIMER_ABSTIME() {
        return TIMER_ABSTIME;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __struct_tm_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_tm_defined 1
     * }
     */
    public static int __struct_tm_defined() {
        return __struct_tm_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int __itimerspec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __itimerspec_defined 1
     * }
     */
    public static int __itimerspec_defined() {
        return __itimerspec_defined;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = time_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = time_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = time_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = time_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = time_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = time_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = time_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = time_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = time_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = time_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = time_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = time_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = time_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = time_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = time_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = time_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = time_h.C_POINTER;

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_LONG    );

        public static final MemorySegment ADDR = time_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_LONG,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_DOUBLE,
            time_h.C_LONG,
            time_h.C_LONG
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_LONG,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_LONG,
            time_h.C_POINTER,
            time_h.C_LONG,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_LONG,
            time_h.C_POINTER,
            time_h.C_LONG,
            time_h.C_POINTER,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_POINTER,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_POINTER,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_POINTER,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_POINTER,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, time_h.C_POINTER);
        public static final MemorySegment SEGMENT = time_h.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = time_h.C_INT;
        public static final MemorySegment SEGMENT = time_h.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = time_h.C_LONG;
        public static final MemorySegment SEGMENT = time_h.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, time_h.C_POINTER);
        public static final MemorySegment SEGMENT = time_h.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = time_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = time_h.C_INT;
        public static final MemorySegment SEGMENT = time_h.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = time_h.C_LONG;
        public static final MemorySegment SEGMENT = time_h.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_LONG,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_LONG,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_INT
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_INT,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_INT,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_INT,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_INT,
            time_h.C_INT,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_INT,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_INT,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_POINTER,
            time_h.C_INT,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_POINTER,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_POINTER
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            time_h.C_INT,
            time_h.C_POINTER,
            time_h.C_INT
        );

        public static final MemorySegment ADDR = time_h.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long CLOCKS_PER_SEC = 1000000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000000
     * }
     */
    public static long CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
}

